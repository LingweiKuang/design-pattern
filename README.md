## 配置环境
JDK: 17

## 创建型设计模式
### 单例（Singleton）
场景：电商系统中需要一个全局的订单号生成器（OrderIdGenerator）。它必须在多线程环境下保证唯一、性能开销小、允许延迟初始化并能在单个应用实例内被全局访问。
请设计该组件的类结构与获取方式，使其既线程安全又易于测试（可替换/模拟）。

### 工厂方法（Factory Method）
场景：支付服务需要支持多种支付渠道（微信、支付宝、信用卡、钱包等），并且未来会不断增加新的渠道。每种渠道有各自的处理流程和配置项。
请设计一个工厂方法结构，使得新增渠道时最小化改动（对现有代码开闭原则友好），并支持按配置动态创建对应的支付处理器。

### 抽象工厂（Abstract Factory）
场景：公司做跨平台客户端 SDK，要在不同平台/主题下生成一套相关联的 UI 组件族（例如：Button、TextField、Dialog），要保证同一套样式（如 iOS 风格 或 Material 风格）内部组件能互相配合。
请设计抽象工厂如何组织不同平台/主题的组件家族，以及客户端如何按需切换产品族。

### 建造者（Builder）
场景：订单系统需要创建复杂的 Order 对象——包含必填的商品清单、用户信息，以及大量可选项（发票、配送方式、优惠策略、礼品包装、订单备注、第三方保险、分期信息等）。
请设计一个 Builder，使得构造调用链可读、避免构造函数参数炸裂（telescoping constructor），并支持可变的必选/可选字段校验与最终不可变的 Order 对象。

### 原型（Prototype）
场景：在商品管理后台，常见“复制商品”操作：管理员经常基于现有商品快速克隆并只调整少量字段（价格、库存、活动标签）。系统要求克隆操作性能要高（避免重新查询/构建大量子对象），并且有选择性地浅拷贝或深拷贝某些关联数据（如图片、属性、评论）。
请设计一个原型复制方案，说明如何控制浅/深拷贝以及扩展新字段的拷贝策略。

## 结构型设计模式
### 适配器模式（Adapter） — 第三方支付接入
业务场景：你的电商系统需要接入两家第三方支付：PayFast（提供 REST API，方法名 payOrder(amountCents)）和 QuickPay（旧系统，只能用 processPayment(dollars)）。你希望在系统内部统一调用 PaymentGateway.charge(amountInCents)。
要求/考点：定义统一接口并实现两个适配器，处理单位转换（美元/分）与异常封装；展示如何在订单结算处无差异地切换支付实现。

### 桥接（Bridge） — 多渠道通知系统
业务场景：平台要发送通知，通知分为不同“内容类型”（订单通知、营销通知、系统告警），同时有多种“发送渠道”（Email、SMS、Push）。未来可能新增渠道或通知类型。
要求/考点：使用桥接将“通知内容（抽象）”与“发送实现（实现者）”解耦，演示如何在运行时组合任意通知类型与渠道，并保持扩展性。

### 组合（Composite） — 权限菜单与UI树
业务场景：后台管理系统的菜单支持任意层级（目录/菜单项），并对某些节点设置权限（例如角色能看到的菜单）。前端需要遍历树渲染，也需要按角色过滤树。
要求/考点：用组合模式实现 MenuComponent（目录/叶子），支持 render()、filterByRole(role)、add/remove 操作；说明如何用统一接口对叶子与组合进行操作。

### 装饰者（Decorator） — 动态给文本添加功能
业务场景：一个文本处理管道，基础是 Text 对象。业务需要按需给文本添加“加密”、“压缩”、“HTML 转义”、“拼写检查”等功能，且这些功能可以自由组合和顺序叠加。
要求/考点：用装饰者模式实现可组合的文本处理器（动态添加/移除装饰行为），展示装饰器链的构造与执行顺序对结果的影响。

### 外观（Facade） — 订单下单外观
业务场景：下单流程涉及库存检查、价格计算（含优惠/积分）、支付、发货排队、通知。上层只想调用 OrderService.placeOrder(orderDto)。
要求/考点：设计一个外观类封装复杂子系统调用，确保事务边界、错误回滚或补偿策略的基本说明（不用实现复杂事务，只说明点），并示例如何降低上层耦合。

### 享元（Flyweight） — 文档编辑器的字符/样式复用
业务场景：一个富文本编辑器需要展示和处理非常大的文档（百万字符），每个字符有可能带有样式（字体、大小、颜色）。为节省内存，需要大量共享样式对象。
要求/考点：实现享元工厂管理共享的 TextStyle（内在状态），将字符对象分离为内在/外在状态，指出何时不能使用享元（可变内在状态的风险）。

### 代理（Proxy） — 远程服务调用与缓存
业务场景：系统需要频繁查询商品详情，但后端服务响应慢或带宽贵。设计一个代理层，在本地缓存热数据、在未命中时调用远程服务并异步刷新缓存。同时需要控制并发访问（防止缓存击穿）。
要求/考点：用代理模式封装缓存逻辑与远程调用，演示同步代理或智能代理的不同（缓存、访问控制、懒加载、并发保护），并说明缓存一致性与失效策略。


## 行为型设计模式